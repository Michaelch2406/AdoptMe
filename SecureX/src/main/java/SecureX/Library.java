/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package SecureX;
import java.util.Base64;

public class Library {
    
    public static class Hash {
        private static final int BUFFER_SIZE = 128;
        private static final int GRID_WIDTH = 16;
        private static final int GRID_HEIGHT = 8;
        private static final int AMPLIFY_CYCLES = 5;

        /**
         * Rotación a la izquierda de bits
         * @param x valor a rotar
         * @param bits número de posiciones a rotar
         * @param width ancho en bits (por defecto 8)
         * @return valor rotado
         */
        private static int rotateLeft(int x, int bits, int width) {
            int mask = (1 << width) - 1;
            return ((x << bits) & mask) | (x >> (width - bits));
        }

        /**
         * Sobrecarga con width por defecto = 8
         */
        private static int rotateLeft(int x, int bits) {
            return rotateLeft(x, bits, 8);
        }

        /**
         * Fase de preprocesado - convierte la cadena de entrada en un buffer inicial
         * @param inputStr cadena de entrada
         * @return buffer de 128 enteros
         */
        private static int[] preprocess(String inputStr) {
            int[] buffer = new int[BUFFER_SIZE];
            int state = 0;
            int acc = 73;

            for (int i = 0; i < inputStr.length(); i++) {
                int code = (int) inputStr.charAt(i);
                int mixed = code ^ state ^ ((acc * (i + 1)) % 256);
                int rotated = rotateLeft(mixed, (i % 7) + 1);

                int idx1 = (i * 13 + acc) % BUFFER_SIZE;
                int idx2 = (i * 17 + rotated) % BUFFER_SIZE;

                buffer[idx1] ^= rotated;
                buffer[idx2] ^= (rotated ^ code ^ (state % 256));

                state = (state ^ rotated ^ code ^ acc) % 256;
                acc = (acc + code + i * state) % 256;
            }

            return buffer;
        }

        /**
         * Fase de amplificación - aplica mutaciones complejas al buffer
         * @param buffer buffer de entrada de 128 elementos
         * @return buffer amplificado
         */
        private static int[] amplify(int[] buffer) {
            // Convertir buffer a grid 2D
            double[][] grid = new double[GRID_HEIGHT][GRID_WIDTH];
            for (int i = 0; i < BUFFER_SIZE; i++) {
                int y = i / GRID_WIDTH;
                int x = i % GRID_WIDTH;
                grid[y][x] = (double) buffer[i];
            }

            // Ejecutar ciclos de amplificación
            for (int cycle = 0; cycle < AMPLIFY_CYCLES; cycle++) {
                double[][] newGrid = new double[GRID_HEIGHT][GRID_WIDTH];

                // Procesar cada celda de la grilla
                for (int y = 0; y < GRID_HEIGHT; y++) {
                    for (int x = 0; x < GRID_WIDTH; x++) {
                        double val = grid[y][x];

                        // Calcular vecinos (8 direcciones)
                        double mix = val;
                        for (int dy = -1; dy <= 1; dy++) {
                            for (int dx = -1; dx <= 1; dx++) {
                                if (dy == 0 && dx == 0) continue;

                                int ny = (y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                                int nx = (x + dx + GRID_WIDTH) % GRID_WIDTH;
                                double neighbor = grid[ny][nx];

                                mix += Math.sin(neighbor * Math.PI / 256.0) + 
                                       Math.cos(neighbor / (x + 1.0));
                            }
                        }

                        // Aplicar transformaciones trigonométricas
                        double angle = ((x + 1) * (y + 1) + cycle * 13) % 360;
                        val = (mix + Math.sin(Math.toRadians(angle)) + 
                               Math.cos(Math.toRadians(angle / 2.0)) + (x * y)) * (1 + cycle);

                        newGrid[y][x] = Math.abs(val) % 256;
                    }
                }

                // Desplazamiento horizontal por filas
                for (int y = 0; y < GRID_HEIGHT; y++) {
                    double avg = 0;
                    for (int x = 0; x < GRID_WIDTH; x++) {
                        avg += newGrid[y][x];
                    }
                    avg /= GRID_WIDTH;

                    int offset = ((int) avg) % GRID_WIDTH;
                    double[] row = new double[GRID_WIDTH];
                    for (int x = 0; x < GRID_WIDTH; x++) {
                        row[(x + offset) % GRID_WIDTH] = newGrid[y][x];
                    }
                    newGrid[y] = row;
                }

                // Operaciones XOR por columnas
                for (int x = 0; x < GRID_WIDTH; x++) {
                    int colSum = 0;
                    for (int y = 0; y < GRID_HEIGHT; y++) {
                        colSum += (int) newGrid[y][x];
                    }
                    colSum %= 256;

                    int bitmask = colSum / 8;
                    for (int y = 0; y < GRID_HEIGHT; y++) {
                        newGrid[y][x] = ((int) newGrid[y][x]) ^ bitmask;
                    }
                }

                grid = newGrid;
            }

            // Convertir grid de vuelta a buffer plano
            int[] result = new int[BUFFER_SIZE];
            for (int i = 0; i < BUFFER_SIZE; i++) {
                int y = i / GRID_WIDTH;
                int x = i % GRID_WIDTH;
                result[i] = ((int) grid[y][x]) & 0xFF; // Asegurar que esté en rango 0-255
            }

            return result;
        }

        /**
         * Genera Hash en formato hexadecimal
         * @param inputStr cadena de entrada
         * @return Hash en formato hexadecimal
         */
        public static String hashHex(String inputStr) {
            return hash(inputStr, OutputMode.HEX);
        }

        /**
         * Genera Hash en formato Base64
         * @param inputStr cadena de entrada
         * @return Hash en formato Base64
         */
        public static String hashBase64(String inputStr) {
            return hash(inputStr, OutputMode.BASE64);
        }

        /**
         * Función principal de Hash
         * @param inputStr cadena de entrada
         * @param outputMode modo de salida (HEX o BASE64)
         * @return Hash en el formato especificado
         */
        public static String hash(String inputStr, OutputMode outputMode) {
            if (inputStr == null) {
                throw new IllegalArgumentException("La cadena de entrada no puede ser null");
            }

            // Fase 1: Preprocesado
            int[] baseBuffer = preprocess(inputStr);

            // Fase 2: Amplificación
            int[] finalBuffer = amplify(baseBuffer);

            // Convertir a bytes
            byte[] finalBytes = new byte[finalBuffer.length];
            for (int i = 0; i < finalBuffer.length; i++) {
                finalBytes[i] = (byte) (finalBuffer[i] & 0xFF);
            }

            // Formatear salida
            if  (outputMode == OutputMode.HEX) {
                    return bytesToHex(finalBytes);
            }else if (outputMode == OutputMode.BASE64) {
                return Base64.getEncoder().encodeToString(finalBytes);
            }

            return null;
        }

        /**
         * Convierte array de bytes a string hexadecimal
         * @param bytes array de bytes
         * @return string hexadecimal
         */
        private static String bytesToHex(byte[] bytes) {
            StringBuilder hexString = new StringBuilder();
            for (byte b : bytes) {
                String hex = Integer.toHexString(0xFF & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        }

        /**
         * Enum para los modos de salida
         */
        public enum OutputMode {
            HEX,
            BASE64
        }
    }
    
    public static class Utils {
        /**
        * Verifica si un Hash coincide con el texto original
         * @param input
         * @param hash
         * @return 
        */
       public static boolean verifyBase64(String input, String hash) {
           return hash.equals(Hash.hashBase64(input));
       }

       /**
        * Verifica Hash en formato hex
         * @param input
         * @param hash
         * @return 
        */
       public static boolean verifyHex(String input, String hash) {
           return hash.equals(Hash.hashHex(input));
       }
    }
    
}
